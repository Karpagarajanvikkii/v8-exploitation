# Initial Analysis
After analyzing the provided patch, we can see a Builtin added called **Hole** is added which returns the **TheHole** value from an array, After looking into what the Hole value is, we understand why leaking it is dangerous and can lead to further vulnerabilities like memory corruption because of the special handling of it by the **JsMap** object. This challenge is based of off **CVE-2021-38003** which was used in the wild to achieve RCE, the working behind it is when an builtin is executed in v8
and it returns an exception, the **Pending Exception** member is set and the execution of the builtin is aborted and an exception value is returned, which makes the code jump into v8's exception handling and the pending exception members  are fetched from the current isolate and JS, lastly when no exception is pending the pending exception member is set to the **HoleValue**. Where things go wrong is when **JsonStringifier** failed to set the pending exception member and yet an exception is returned from **JsonStringifier** which in turn leaks the Holevalue which can be used to manipulate an Map's length via map.set, where the hole value can be deleted twice and makes the length of the map to be **-1**, This affects the **OrderedhashMap** capacity and buckets to increase, with the value the attacker provides.

# Exploitation 
We start by Writing the helper functions **ftoi** and **itof** to help us convert values and leaks between integers and floats, we define an empty array called v and define a new map object and set the hole as one of its value and delete that twice as per the **POC** , which in turn makes the length of the map to -1, proceeding further we define an float array called **oob_arr**, we try to change the length of the map via map.set and we know that the oob_arr will be next in memory to the **table** of the map so when the capacity of the table is increased, the buckets will also be increased, in turn the first entry of the map's key will be stored in the oob arrays length, now we set the maps value again to oob_arr and an large length which **overwrites the oob_arr elements pointer and its length** changing its length, now we can use the oob_arr to construct the addrof,  read and write primitives.

# addrof  

To construct the addrof primirive we define an array of empty objects called **victim**, then set one of the elements of the victim to the targeted object, which will then contain a pointer to the target object(lower 32 bits) and then we use the oob_arr to read the addr by finding the correct index of the first element of victim , we also add an mask so only the lower 32bits are returned.

# Read and Write

To construct the read and write primitive we define an float array called **arb_gadget** , We use the oob_arr to overwrite the elements pointer of **arb_gadget** after finding its index, for read we just return the arb_gadget's index[0]  and the value from the desired address will be returned and for write we follow the same process with a slight difference we just write the value we want to write into arb_gadget[0], **0x600000000 is added with the address because oob_arr is overwriting the full 64-bit value of the given address, thats why we add  0x600000000 as the upper 32 bits value**

# Controlling RIP and JIT spraying

When an javascript function is called it jumps to the address in the **code** and **code_entry_point** field so if we overwrite this we can make it point to our shellcode and make it execute the shellcode, for the shellcode we have to write it  in immediate numbers and convert it into float values, for this we define a function called foo which contains our shellcode and is jit-optmised  by making the function hot, we use our read and write primitives to overwrite the **code_entry_point** of the foo function, as the last step we find the offset of where our shellcode begins in the JITed code and overwrite the **code_entry_point**, then we call the foo function and it executes our shellcode and get a shell.
