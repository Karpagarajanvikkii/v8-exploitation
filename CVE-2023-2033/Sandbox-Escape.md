# Sandbox Escape using  raw pointers in WasmIndirectFunction:targets


# 0x01
We Setup the environment with the expose_memory_corruption_api enabled as it helps us to test the security of the sandbox more easily, it also has an Addrof primitive that we can use directly via Sandbox.getAddrOf, so we define the addrof, heap_read and write.

# Initial analysis
Looking into the targets field of the **WasmIndirectFunctionTable's**  we find that it has **raw pointers**  pointing to an memory area that is outside of the sandbox, so if we can set the targets field to an arbitrary value then we can achieve **arbitrary write**. For this we must understand what is a module,instance and a table and how they work.

# Module 
A module in WebAssembly is a set of stateless webassemly code, we can also spawn processes from it,  a WebAssembly module can contain exported functions

# Instance 
 
An Instance is a stateful, executable object created from a Module. when we create  a module, the instance can import JavaScript functions and WebAssembly tables.

# Table

Understanding what tables are and how they work are important to replicate this technique, A table is an array of functions which can be 
accessed using indexes, The entries in an table are readable and writable 
In V8, tables are implemented as **WasmTableObject** and instances are implemented as **WasmInstanceObject**, When an instance imports an table it is stored inside the **tables** field of the **WasmInstanceObject**,
An **WasmIndirectFunctionTable** is then allocated which is stored inside the **indirect_function_tables** field of the WasmInstanceObject,
the **targets** field of the WasmIndirectFunctionTable stores the function pointers in  WasmTableObject, and the imported functions are stored in the **imported_function_targets** field of the WasmInstanceObject  

# Getting arbitrary write using the targets field 

After analyzing the code which accesses the targets field of the WasmindirectFunctionTable we can that see that **WasmindirectFunctionTable::set** sets the **call target** to the memory area pointed by the targets,so we need to find where the call target value comes from, so we begin to analyze **WasmTableObject::Set**, we can see that it calls **WasmTableObject::SetFunctionTableEntry** , this checks if the function passed to WasmTableObject::set is of type wasmExportedFunction if so it gets the parent **WasmInstanceObject** of the WasmExportedFunction. it loads the index of the exported function, Then it calls **WasmTableObject::UpdateDispatchTables** with all the values, There we can see that it iterates through the dispatch tables updates the WasmindirectFunctionTable for  each entry , and we can also see that the call_target value passed to WasmIndirectFunctiontable::set is the return value **Wasminstanceobject::GetCallTarget**, The WasmInstanceObject::GetCallTarget returns  the code pointer  of a WebAssembly and the function index for it in the instance is the func_index. The **func_index** parameter can be for an imported function or an exported function. if the function is an imported function, the call target will be retrieved from **imported_function_targets**, or if its an exported function the value will retrieved from the **jump_table_start**.  imported_functions_targets is a compressed pointer, in the Getcalltarget we note this specific line **if (func_index < native_module->num_imported_functions()) { return imported_function_targets().get(func_index);  
  }** so what that means if we can set the func_index of an exported function 0 we can make the CallTarget return a value from the imported_function_targets, which set using our heap read and write, 
 so now to get arbitrary  write we overwrite the targets pointer of the WasmIndirectFunctionTable, **this will be the Where pointer of our arbitrary write**, and we overwrite the contents pointed to by the imported_function_targets **this will be the what pointer of our arbitrary write**.
 
 # Getting code execution
 The  pointers in  imported_function_targets are raw pointers with **RWX permissions**, so we can copy our shellcode to this rwx area and execute it by calling the overwritten imported function with an WasmExportedFunction, we do this and we successfully escape the sandbox and spawn /bin/sh.


