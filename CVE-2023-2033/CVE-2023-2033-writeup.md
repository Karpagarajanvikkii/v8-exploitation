# CVE-2023-2033


# Initial analysis

The CVE deals with leaking **TheHole** value because of incorrect **JIT optimisation** , when JsGlobalProxy is provided as an argument to Error.captureStackTrace, to understand this behavior, we first need to understand what is **JSGlobalProxy** and **JsGlobalObject** and what's the relation between them  and also about the **StackTrace api**,**property descriptors** and **dependent code**.

# JSGlobalProxy

A **proxy** in javascript intercepts request made to an target object and some predefined actions, **JSGlobalProxy** is a proxy whose target object is **JsGlobalObject**, and also  **JsGlobalObject** cant be accessed with **%DebugPrint** or from javascript so we must use **JsGlobalProxy**, JsGlobalProxy's **prototype** is JsGlobalObject , JsGlobalProxy always delegates property accesses to its prototype if its present.

# JSGlobalObject

JSGlobalObject is different from regular objects because it manages properties differently, the properties of **JsGlobalObject** are stored in a **GlobalDictionary** which stores properties in the form of **property cells** which are name,detail and value pairs.


# StackTrace api

All Errors thrown in v8  capture a stack trace when they occur, this stack  trace can be accessed via the Error.stack property, we can also access the stack trace for custom exceptions using error.captureStackTrace  and we can also customize this stack trace using Error.prepareStackTrace 

# Property Descriptors 

Every property in an javascript object has three descriptors, **enumerable, configurable and writable**  and these descriptors can be viewed with either **Object.getOwnPropertyDescriptor to get the descriptors of a specific property such as a** or **Object.getOwnPropertyDescriptors to get the descriptors of all properties** and **Object.defineProperty can be used to define these descriptors**.



# Dependent code

Dependent code is an **array which contains the possibilities of deoptimization for JIT compiled functions** where code is the code of the optimized function and **Dependency Groups are the reason for deoptimization** .

# Exploitation

When Turbofan compiles a function access to global variables are handled by **JSNativeContextSpecialization::ReduceGlobalAccess()** and looking into how it optimizes propertycell's we find  that if both writable and configurable are set to false it is optimized as a constant value if not it optimizes the address of the  property cell as a **HeapConstant**, basically what it does is get the value of the property cell directly by accessing the memory address, so what we do is define a variable(stack) as a constant first(1) and then change it to {}, this makes the property cell mutable and it is optimized as a **HeapConstant** thus returning the value of the propertycell, and another interesting to note here is when you delete a propertycell(stack), only the propertycell of the stack property will be removed from the **globaldictionary** object but the property cell itself will remain in memory which contains **TheHole** value, thus if stack is deleted after it is optimized as a **HeapConstant**, the propertycell will return **TheHole** value, But Deoptimization occurs and we are not able to get the Hole value, so after analysing  Dependent code and Dependency groups we find why it is marked for deoptimization, it seems that because the object is mutable(can be deleted,changed and is not read-only) KPropertyCellChangedgroup comes into play and marks it for deoptimization, so in order to avoid deoptimization we should make the stack property to **configurable:false** but the property cant be deleted after making it non-configurable and this is where Error.captureStackTrace and Error.prepareStackTrace comes into play, we set configurable:false inside the error.PrepareStackTrace  and make it configurable again and delete it, hence as a result we avoid deoptimization and successfully leak  **TheHole** value.

# Patch

The Quick patch for the vulnerability was when **JsGlobalProxy** was provided as an argument to **Error.PrepareStackTrace**, it is made to return undefined and the full fix was to change Error.stack into a **javascript accessor**  instead of a native data property this fixed the JS-Spec violation that when reading from a data property there are **no observable side effects**.
