# Krautflare: Exploiting the typing vulnerability in math.expm1 

# 0x01 
After reading the patch we can see that it patches math.expm1 to the state it was before the patch, the problem here is that the **typer** normally  sets the type of math.expm1 to Union(PlainNumber, NaN), but it failed  to handle the -0 case and returns -0. 


# Initial analysis 
 
 The part where things get interesting is when **Object.is** is used to compare -0  with math.expm(-0), this is because the typer thinks this will be always false, but when checked it isnt, it returns true so -0 is not typed as a PlainNumber or NaN and is actually -0 at runtime. The typer runs in 3 stages, during the typer phase,load elimination phase and the simplified lowering phase. The constraint here is we dont want the typer to determine we are comparing against -0 too soon and not too late. The call to Object.is starts as a **SameValue** node and is further reduced to specialized nodes(ObjectisMinusZero) in our case by the typer which has a pass known as **TypedOptimization** which reduces nodes. Type information is propagated via **updateTypeFeedback** for SameValue nodes but not for ObjectisMinusZero nodes so we need to find a way to keep the sameValue node until simplified lowering phase. Another obstacle is the math.expm1 function doesn't handle -0 and it will get truncated into 0 so we also need to call the builtin of the function by making it hot and providing **"0"** as strings are not handled by the function itself but by the builtin. so with one constraint satisfied, we focus on finding a way to keep the sameValue node around, we see that the last **TypedOptimization  pass** is run in the load elimination phase before **escape analysis**  so we use escape analysis to our advantage and we store the -0 inside an non-escapable object's property  and compare against it so that the typer won't know that we are comparing againt -0 until EscapeAnalysis is done. This keeps the SameValue node around until the  SimplifiedLowering phase and also  the type information is propagated. The last typing run on SimplifiedLowering  phase will determine that the  SameValue is always false, and  propagates this information, which in turn **removes the bounds check** and we can trigger out-of-bounds now.

# Exploitation
  now with the **OOB** in place, we try to get our addrof, arbitrary read and write primitives. In order to do that we corrupt the length of an array first and use it as oob_array, then we define an object and an ArrayBuffer we use the object to get addrof and we overwrite the backing store of the Arraybuffer for arbitrary read and write to find the offsets of both which can be accesed via the oob_array, we use an loop to find specific values and find the offsets. with the offsets in hand we now build our read and write primitives. To get code execution we create an WasmInstance which has a rwx page on which we can write our shellcode to pop calc. We find the offset of the rwx_page and write our shellcode to it and pop calc.
